package lesson.lesson4

// Бывают случаи, когда необходимо расширить поведение класса, но доступа к самому классу нет, либо вам в отдельном
// месте вашего кода понадобился удобный метод, который бы работал с данными нужного класса и при этом вы не хотите
// добавлять этот новый метод в соответствующий класс, чтобы не перенагружать класс.
//Чтобы объявить функцию расширения необходимо:
// - создать обычную функцию
// - к имени функции дописать префикс в виде MyClass()., где MyClass - это класс, который вы хотите расширить.
// Представим, что у нас нет доступа к классу Person и мы не можем сделать функцию получения полного имени внутри
// класса. Мы можем объявить функцию расширения:
data class Person(
    val name: String,
    val surname: String,
)

// fun Person.getFullName(): String = "$name $surname"

// Так как у функции есть префикс в виде класса, который мы расширяем, в самой функции мы получаем полный доступ к его
// public свойствам.

//----------------------------------------------------------------------------------------------------------------------

// Доступность
// Почему доступ только к public свойствам? Наш код никак не может повлиять на исходный код нужного нам класса, он не
// встраивается внутрь него на этапе компиляции.
// Данный код после компиляции превратится в обычную функцию принимающую тип, который мы объявили для расширения:
// до компиляции
// fun Person.getfullName() : String = name + surname
// после компиляции
// @NotNull
// public String getFullName(@NotNull Person $this$getFullName) {
//     Intrinsics.checkNotNullParameter($this$getFullName, "<this>");
//     return $this$getFullName.getName() + $this$getFullName.getSurname();
// }

//----------------------------------------------------------------------------------------------------------------------

// Конфликт
// data class Person(
//     val name: String,
//     val surname: String,
// ) {
//     fun getFullName(): String = "Full name: $name $surname"
// }
// fun Person.getFullName() : String = name + surname
// В случае когда в классе уже есть функция с таким именем и одинаковыми аргументами, всегда будет вызываться
// оригинальный метод класса.

//----------------------------------------------------------------------------------------------------------------------

// Не только функции
// Можно сделать расширение, которое будет выглядеть, будто у класса появилось новое свойство
val Person.fullname
    get() = "$name $surname"
// Стоит отметить, что хоть в Kotlin оно и выглядит как новое свойство, после компиляции это будет выглядеть как
// обычный метод:
// public String getFullname(@NotNull Person $this$fullname) {
//   Intrinsics.checkNotNullParameter($this$fullname, "<this>");
//   return $this$fullname.getName() + $this$fullname.getSurname();
// }

//----------------------------------------------------------------------------------------------------------------------

// Ссылки
// Мы также можем использовать function type (тип функции) для описания нашей функции расширения, ведь она обычная
// функция. Мы знаем, во что данная функция превратится после компиляции:
// fun getFullName(p: Person): String = "${p.name} ${p.surname}"
// @NotNull
// public String getFullName(@NotNull Person $this$getFullName) {
//   Intrinsics.checkNotNullParameter($this$getFullName, "<this>");
//   return $this$getFullName.getName() + $this$getFullName.getSurname();
// }

// А значит мы можем догадаться о том, как будет выглядеть наш function type:
// val fullName: (Person) -> String = Person::getFullName
// Это нужно для случаев, когда нам необходимо передать функцию как аргумент другой функции
