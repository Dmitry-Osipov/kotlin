package com.osipov.lesson.lesson1

fun main() {
    val x = 10;
//    x = 20 val - неизменяемая переменная (как final в java)
    var y = 20
    y = 10
    println("Hello World!")
    val z: Int  // Переменная не была инициализирована сразу, так что требуется указать её тип
    z = 42

    //------------------------------------------------------------------------------------------------------------------

    val pair = Pair("Kotlin", 1)  // При создании объекта не требуется слово new
    println(pair.first)
    println(pair.second)

    //------------------------------------------------------------------------------------------------------------------

    // В примерах ниже типы можно было не указывать, но они оставлены для наглядности
    val immutableList: List<Int> = listOf(1, 2, 3)
//    immutableList.add(4) - Ошибка: метод add недоступен
    val mutableList: MutableList<Int> = mutableListOf(1, 2, 3)
    mutableList.add(4)  // Успешно добавляем новый элемент

    val myMap: Map<String, Int> = mapOf(  // Неизменяемый тип
        "Apple" to 1,
        "Banana" to 2,
        "Cherry" to 3
    )
    val mutableMap: MutableMap<String, Int> = mutableMapOf(  // Изменяемый тип
        "Apple" to 1,
        "Banana" to 2
    )
    mutableMap["Cherry"] = 3  // Добавление новой пары

    //------------------------------------------------------------------------------------------------------------------

    // В Kotlin отсутствуют примитивы, вместо этого всё является объектами
    val number = 42  // Число является объектом типа Int
    val isTrue = true  // Логическое значение - объект типа Boolean
    val doubled = 21.times(2)  // Из-за того, что всё объекты, можно вызвать методы класса прямо на объекте,
    // а не переменной
    println(doubled)  // 42

    //------------------------------------------------------------------------------------------------------------------

    // Массивы представляются классом Array, для каждого условно "примитивного" типа существует специальный класс
    // (IntArray, DoubleArray)
    val array = arrayOf(1, 2, 3)  // Array<Int>
    println(array[0])
    val intArray = intArrayOf(1, 2, 3)  // IntArray
    println(intArray[1])
    // создаем массив фиксированного размера
    // и заполняем с помощью лямбда-выражения:
    // в каждую ячейку положим число, полученное умножением индекса на 2
    // (лямбда выражения разберем позже)
    // для вывода в консоль используем
    // встроенный метод преобразования массива в строку
    val arrayWithFixedSize = Array(5) { index -> index * 2 }  // Как и прошлые массивы, этот имеет
    // фиксированный размер
    println(arrayWithFixedSize.joinToString())  // Метод toString также возвращает неинформативное значение

    //------------------------------------------------------------------------------------------------------------------

    val name = "Dmitry"  // Строки представлены классом String. Также являются неизменяемыми
    val hello = "Hello $name! Your name has ${name.length} letters"
    println(hello)
    val text = """
        This is multi-line string.
        It preserves the format
        and allows easy handling of large text.
    """.trimIndent()  // Kotlin поддерживает многострочные строки, однако требует вызова метода для подрезания отступов
    println(text)

    // Числа в Kotlin представлены классами Int, Long, Double, Float, Short, Byte. Поскольку числа - это объекты,
    // они поддерживают методы и операторы.
    //
    // В Kotlin преобразования типов неявно не выполняются, их нужно делать явно. Kotlin поддерживает операции с
    // числами, как и в Java, но с дополнительными методами для работы с ними.
    val a = 10
    val b = 20
    val sum = a + b

    val intNumber = 42
    val doubleNumber = intNumber.toDouble()  // Явное преобразование

    val q = 10
    val w = 3
    println(q / w)  // 3 - целочисленное деление
    println(a.toDouble() / w)  // 3.3333333333333335 - деление с преобразованием типов

    //------------------------------------------------------------------------------------------------------------------

    // В Kotlin доступны основные типы циклов: for, while, do-while.
    // Цикл for используется для итерации по коллекциям, диапазонам (ranges), массивам и строкам.
    val items = listOf("apple", "banana", "kiwi")
    for (item in items) {  // По коллекции
        println(item)
    }

    for (i in 1..5) {  // По диапазону
        println(i)
    }

    for (i in 10 downTo 1 step 2) {  // По диапазону с шагом и в обратном порядке
        println(i)
    }

    // Циклы while и do-while работают так же, как и в Java
    var e = 5
    while (e > 0) {
        println(e)
        e--
    }

    var r = 5
    do {
        println(r)
        r--
    } while (r > 0)

    //------------------------------------------------------------------------------------------------------------------

    // Kotlin поддерживает традиционные конструкции ветвления if-else и when, но они могут быть использованы более
    // гибко и выразительно.
    // Например, конструкция if может возвращать значение, что позволяет использовать её как выражение, а значит,
    // тернарный оператор как в Java больше не нужен:
    val ten = 10
    val twenty = 20
    // if возвращает значение, похоже на тернарный оператор
    val max = if (a > b) a else b
    println(max)

    val negativeNumber = -10
    val result = if (negativeNumber > 0) {  // Тут if тоже возвращает значение
        "Positive"
    } else if (negativeNumber < 0) {
        "Negative"
    } else {
        "Zero"
    }
    println(result)

    // Конструкция when в Kotlin аналогична switch в Java, но более мощная и универсальная. Она также может
    // возвращать значение.
    val two = 2
    when (two) {
        1 -> println("One")
        2 -> println("Two")
        3 -> println("Three")
        else -> println("Unknown number")
    }

    val three = 3
    val description = when (three) {  // Возвращает значение
        1 -> "One"
        2 -> "Two"
        3 -> "Three"
        else -> "Unknown"
    }
    println(description)

    // when может работать без аргумента, что позволяет использовать его как альтернативу множественным if-else
    // конструкциям:
    val res = when {
        two > three -> "Two is greater"
        two < three -> "Three is greater"
        else -> "Two equals three"
    }
    println(res)

    // есть некий объект obj, его тип нам неизвестен:
    // в Java это был бы тип Object, в Kotlin это тип Any
    val obj = Any()
    when (obj) {
        is Int -> println("Integer")
        is String -> println("String")
        else -> println("Unknown")
    }

    //------------------------------------------------------------------------------------------------------------------

    // Kotlin изначально разработан для обеспечения безопасности работы с null, что является одной из частых причин
    // ошибок в Java. В Kotlin система типов разделяет объекты на те, которые могут принимать значение null, и те,
    // которые не могут.
    // В Kotlin по умолчанию переменные не могут содержать null:
    val str1: String = "Hello"
//    val st2: String = null - ошибка компиляции
    val str2: String? = null // Если переменная может принимать значение null, необходимо явно указать это, добавив ?

    // Kotlin предоставляет несколько способов безопасной работы с переменными, которые могут быть null.
    // Оператор ?. позволяет вызвать метод или получить свойство объекта, только если объект не равен null. Если объект
    // null, выражение возвращает null вместо вызова метода или выбрасывания исключения:
    val str3: String? = null
    val str3Length: Int? = str3?.length
    println(str3Length)

    // Оператор ?: (называется “элвис-оператор”, или “оператор Элвиса”, за схожесть с прической известного музыканта)
    // используется для предоставления значения по умолчанию в случае, если выражение слева возвращает null. Это
    // позволяет избежать написания длинных условных конструкций:
    val strLength = str3?.length ?: 0  // Если b не равно null, верни b.length, иначе верни 0
    println(strLength) // Output: 0

    // Оператор !! используется для того, чтобы явно указать, что переменная не должна быть null. Если всё же
    // оказывается null, то будет выброшено NullPointerException: println(str3!!.length) - Использование этого оператора
    // следует избегать, так как оно нарушает безопасный подход работы с null, который предлагает Kotlin. Однако бывают
    // ситуации (обычно они возникают, когда автоматическое приведение типов не сработало, об этом ниже), когда без него
    // не обойтись - в этом случае следует оставить комментарий в коде, почему данный объект не может быть null -
    // например, потому что был проверен ранее.

    // Kotlin обладает удобной возможностью автоматического приведения типов после проверки на null. Если переменная
    // была проверена на null, то внутри блока, где эта проверка прошла, она автоматически перестает быть nullable:
    val kotlin: String? = "Kotlin"
    if (kotlin != null) {
        println(kotlin.length)  // Автоматическое приведение к типу String. Аналогичное приведение к nonnull-типу
        // происходит при использовании оператора !!
    }

    // Функция let позволяет выполнить блок кода в том случае, если переменная не null (похоже на Optional в Java):
    kotlin?.let {
        println("String length is ${it.length}")
    }

    // Kotlin позволяет создавать коллекции, содержащие null, а также коллекции, которые сами могут быть null :
    val list1: List<String?> = listOf("Kotlin", null, "Java")  // Коллекция с null типами
    val list2: List<String>? = null  // nullable коллекция

    //------------------------------------------------------------------------------------------------------------------

    fun greet1(name: String): String {  // В Kotlin методы объявляются с использованием ключевого слова fun. Это одно из
        // самых заметных отличий от Java, где для объявления метода используется возвращаемый тип перед именем метода.
        return "Hello $name!"
    }
    // Этот метод принимает строку name в качестве параметра и возвращает строку с приветствием. Синтаксис:
    // - fun: ключевое слово, используемое для объявления метода.
    // - greet(name: String): имя метода и его параметры.
    // - : String: тип возвращаемого значения, который указывается после параметров.
    // - return: инструкция для возврата значения, аналогичная Java.

    // Одной из мощных особенностей Kotlin являются параметры по умолчанию. Это позволяет не перегружать методы, как в
    // Java, и использовать значения по умолчанию, если аргументы не были переданы при вызове метода:
    fun greet2(name: String = "Guest"): String {
        return "Hello $name!"
    }
    println(greet2())
    println(greet2("Kotlin"))

    // Kotlin позволяет использовать именованные параметры при вызове метода. Это особенно полезно, когда метод имеет
    // несколько параметров одного типа или когда вы хотите пропустить некоторые параметры и использовать значения
    // по умолчанию:
    fun formatMessage(
        text: String,
        prefix: String = "",
        suffix: String = ""
    ): String {
        return "$prefix$text$suffix"
    }
    println(formatMessage("Hello", suffix = "!"))
    // Здесь при вызове метода formatMessage используется только параметр suffix, в то время как prefix остаётся пустым.
    // Обратите внимания на стиль написания метода:
    // - параметры перечислены в столбик, каждый с новой строки и с одинарным отступом
    // - у последнего параметра метода оставлена запятая - так называемая “trailing comma”
    // - круглые скобки также расставлены особым образом - каждая на своей строке, но не в строке с параметрами

    // Kotlin поддерживает объявление методов, которые содержат только одно выражение, в упрощённой форме. Вместо
    // использования фигурных скобок и ключевого слова return, можно просто указать выражение после =, которое
    // будет возвращено:
    fun square1(x: Int): Int = x * x  // Так можно
    fun square2(x: Int) = x * x  // Так не рекомендуется

    // Если метод не возвращает значение, в Kotlin используется тип Unit, аналогичный void в Java. Но в большинстве
    // случаев этот тип можно опустить, так как он используется по умолчанию:
    fun printMessage1(message: String): Unit {
        println(message)
    }

    fun printMessage2(message: String) {  // эквивалентная запись
        println(message)
    }
    // Методы можно объявлять как внутри классов, так и вне классов - так называемые верхнеуровневые (top-level)
    // функции. Это позволяет избежать создания статических утилитных классов, как это делается в Java. Такие функции
    // можно импортировать и вызывать напрямую, без создания экземпляра класса.

    //------------------------------------------------------------------------------------------------------------------

    // В Kotlin ключевое слово return используется для выхода из функций, методов, циклов или блоков кода. Однако, в
    // отличие от Java, в Kotlin можно использовать метки с ключевым словом return, что делает возможным прерывание
    // выполнения не только на уровне функции, но и в более сложных конструкциях, таких как лямбды и вложенные циклы.
    // В простейшем случае ключевое слово return используется для завершения функции и возврата результата:
    fun simpleReturn(): Int {
        return 42
    }
    // Метки с ключевым словом return позволяют контролировать выход из вложенных конструкций, таких как циклы или
    // лямбды. Они нужны для более точного управления потоком программы, когда требуется выйти не из текущего уровня
    // выполнения, а из более внешнего контекста.
    // Нужно отметить, что некоторые статические анализаторы кода сигнализируют о проблемах в коде и требуют
    // рефакторинга, когда находят метки в return, поэтому решение об использовании или запрете данной конструкции
    // принимается на каждом проекте индивидуально.
    // Одно из самых частых применений меток — управление возвратом из лямбда-выражений. Более подробно про лямбды мы
    // поговорим в следующих уроках, поэтому если в данном материале будет что-то непонятно - можно будет вернуться к
    // прочтению после изучения нужных тем. В Kotlin лямбды могут содержать ключевое слово return, но оно по умолчанию
    // возвращает значение из всей функции, в которой лямбда находится. Для выхода только из лямбды используется
    // return с меткой:
    fun lambdaWithoutLabel(): List<Int> {
        val numbers = listOf(1, 2, 3, 4, 5)
        return numbers.map {
            if (it == 3) return emptyList()  // Выход из всей функции, когда число равно 3
            it * 2
        }
    }
    println(lambdaWithoutLabel())
    // Здесь использование return приводит к возврату из всей функции lambdaWithoutLabel, когда элемент равен 3.

    // Используя метку, можно выйти только из лямбды, не прерывая выполнение всей функции:
    fun lambdaImplicitLabel(): List<Int> {
        val numbers = listOf(1, 2, 3, 4, 5)
        return numbers.map {
            if (it == 3) return@map 0  // Метка @map используется неявно
            it * 2
        }
    }
    println(lambdaImplicitLabel())

    // Метки также могут быть использованы для того, чтобы прерывать методы с помощью return:
    fun returnFromMethodWithLabel() {
        run loop@{
            for (i in 1..5) {
                if (i == 3) return@loop  // Прерываем выполнение run, не метода
                println(i)
            }
        }
        println("End of method")
    }
    returnFromMethodWithLabel()
    // Здесь return@loop прерывает только метод run (который является функцией высшего порядка, принимающей на вход
    // лямбду), а не всю функцию, тем самым позволяя вывести сообщение "End of method".
}
